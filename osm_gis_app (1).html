<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIS App - OSM Commerce Export</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow-y: auto;
        }
        
        .map-container {
            flex: 1;
            position: relative;
            background: white; /* Fond blanc pour la carte */
        }
        
        #map {
            height: 100%;
            width: 100%;
            background: white !important;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 1.5rem;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
        }
        
        .control-group {
            margin-bottom: 25px;
            background: rgba(255, 255, 255, 0.7);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #34495e;
            font-size: 0.9rem;
        }
        
        select, input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
            box-sizing: border-box;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(17, 153, 142, 0.3);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .loading {
            display: none;
            text-align: center;
            color: #667eea;
            font-weight: 600;
            margin: 10px 0;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .info-panel {
            background: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.85rem;
        }
        
        .layer-info {
            background: rgba(46, 204, 113, 0.1);
            border: 1px solid rgba(46, 204, 113, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .layer-info h3 {
            margin: 0 0 8px 0;
            color: #27ae60;
            font-size: 1rem;
        }
        
        .popup-content {
            max-width: 300px;
        }
        
        .popup-content h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 1.1rem;
        }
        
        .popup-content p {
            margin: 5px 0;
            font-size: 0.9rem;
        }
        
        .popup-content .address {
            color: #7f8c8d;
            font-style: italic;
        }
        
        .popup-content .tags {
            background: #ecf0f1;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            max-height: 120px;
            overflow-y: auto;
        }
        
        .popup-content .tag {
            display: block;
            font-size: 0.8rem;
            color: #34495e;
            margin: 2px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>üó∫Ô∏è GIS Commerce OSM</h1>
            
            <div class="control-group">
                <label for="commerce-type">Type de commerce :</label>
                <select id="commerce-type">
                    <option value="">-- S√©lectionner un type --</option>
                    <option value="shop=bakery">ü•ñ Boulangerie</option>
                    <option value="shop=supermarket">üõí Supermarch√©</option>
                    <option value="shop=convenience">üè™ √âpicerie</option>
                    <option value="shop=butcher">ü•© Boucherie</option>
                    <option value="shop=clothes">üëï V√™tements</option>
                    <option value="shop=pharmacy">üíä Pharmacie</option>
                    <option value="shop=florist">üå∏ Fleuriste</option>
                    <option value="shop=hairdresser">üíá Coiffeur</option>
                    <option value="shop=books">üìö Librairie</option>
                    <option value="shop=jewelry">üíé Bijouterie</option>
                    <option value="amenity=restaurant">üçΩÔ∏è Restaurant</option>
                    <option value="amenity=cafe">‚òï Caf√©</option>
                    <option value="amenity=bar">üç∫ Bar</option>
                    <option value="amenity=bank">üè¶ Banque</option>
                    <option value="amenity=fuel">‚õΩ Station-service</option>
                    <option value="amenity=hospital">üè• H√¥pital</option>
                    <option value="amenity=school">üéì √âcole</option>
                    <option value="amenity=post_office">üìÆ Bureau de poste</option>
                </select>
            </div>
            
            <div class="control-group">
                <button class="btn btn-primary" id="create-layer">
                    üìç Cr√©er la couche
                </button>
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    R√©cup√©ration des donn√©es...
                </div>
            </div>
            
            <div class="control-group">
                <label for="layer-name">Nom de la couche (optionnel) :</label>
                <input type="text" id="layer-name" placeholder="Ex: Boulangeries_Paris">
                <button class="btn btn-success" id="export-btn" disabled>
                    üíæ Exporter en GeoJSON
                </button>
            </div>
            
            <div class="layer-info" id="layer-info" style="display: none;">
                <h3>Couche active</h3>
                <p id="layer-details">Aucune couche cr√©√©e</p>
            </div>
            
            <div class="info-panel">
                <strong>Instructions :</strong><br>
                1. Naviguez sur la carte vers la zone d'int√©r√™t<br>
                2. Choisissez un type de commerce<br>
                3. Cliquez sur "Cr√©er la couche"<br>
                4. Exportez en GeoJSON pour QGIS
            </div>
            
            <div class="control-group">
                <button class="btn btn-primary" id="show-logs" style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);">
                    üîç Afficher les logs de debug
                </button>
            </div>
            
            <div class="layer-info" id="debug-panel" style="display: none;">
                <h3>üîç Logs de Debug</h3>
                <div id="debug-logs" style="background: #2c3e50; color: #ecf0f1; padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.8rem; white-space: pre-wrap;"></div>
                <button class="btn btn-primary" id="clear-logs" style="margin-top: 10px; font-size: 0.8rem; padding: 8px;">Vider les logs</button>
                <button class="btn btn-success" id="copy-logs" style="margin-top: 10px; font-size: 0.8rem; padding: 8px;">üìã Copier les logs</button>
            </div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        console.log('Script charg√©, v√©rification de Leaflet...');
        console.log('L disponible ?', typeof L !== 'undefined');
        
        let map;
        let currentLayer = null;
        let currentData = [];
        let layerType = '';
        let debugLogs = [];
        
        // Fonction de logging personnalis√©e
        function debugLog(message, level = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${level.toUpperCase()}: ${message}`;
            debugLogs.push(logEntry);
            
            // Limiter √† 100 logs pour √©viter la surcharge m√©moire
            if (debugLogs.length > 100) {
                debugLogs = debugLogs.slice(-50);
            }
            
            // Afficher dans la console normale aussi
            if (level === 'error') {
                console.error(message);
            } else if (level === 'warn') {
                console.warn(message);
            } else {
                console.log(message);
            }
            
            // Mettre √† jour le panneau de debug s'il est visible
            const debugPanel = document.getElementById('debug-logs');
            if (debugPanel && document.getElementById('debug-panel').style.display !== 'none') {
                debugPanel.textContent = debugLogs.join('\n');
                debugPanel.scrollTop = debugPanel.scrollHeight;
            }
        }
        
        // Initialisation apr√®s le chargement complet
        function initializeApp() {
            try {
                debugLog('Initialisation de l\'application...');
                
                // V√©rifier que Leaflet est disponible
                if (typeof L === 'undefined') {
                    throw new Error('Leaflet non disponible');
                }
                
                debugLog('Leaflet d√©tect√©, cr√©ation de la carte...');
                
                // Initialiser la carte
                map = L.map('map', {
                    center: [48.8566, 2.3522], // Paris
                    zoom: 13,
                    zoomControl: true
                });
                
                debugLog('Carte cr√©√©e, ajout des tuiles OSM...');
                
                // Ajouter les tuiles OpenStreetMap
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 19
                }).addTo(map);
                
                debugLog('Tuiles ajout√©es, configuration des contr√¥les...');
                
                // Ajouter l'√©chelle
                L.control.scale({
                    position: 'bottomright',
                    metric: true,
                    imperial: false
                }).addTo(map);
                
                // Initialiser les event listeners
                initializeEventListeners();
                
                debugLog('Application initialis√©e avec succ√®s');
                
            } catch (error) {
                debugLog('Erreur d\'initialisation: ' + error.message, 'error');
                document.getElementById('map').innerHTML = '<div style="padding: 20px; text-align: center; color: red;">Erreur de chargement de la carte: ' + error.message + '</div>';
            }
        }
        
        function initializeEventListeners() {
            // √âl√©ments DOM
            const commerceTypeSelect = document.getElementById('commerce-type');
            const createLayerBtn = document.getElementById('create-layer');
            const exportBtn = document.getElementById('export-btn');
            const layerNameInput = document.getElementById('layer-name');
            const loadingDiv = document.getElementById('loading');
            const layerInfo = document.getElementById('layer-info');
            const layerDetails = document.getElementById('layer-details');
            const showLogsBtn = document.getElementById('show-logs');
            const debugPanel = document.getElementById('debug-panel');
            const debugLogsDiv = document.getElementById('debug-logs');
            const clearLogsBtn = document.getElementById('clear-logs');
            const copyLogsBtn = document.getElementById('copy-logs');
            
            debugLog('Event listeners initialis√©s');
            
            // Bouton pour afficher/masquer les logs
            showLogsBtn.addEventListener('click', () => {
                if (debugPanel.style.display === 'none') {
                    debugPanel.style.display = 'block';
                    debugLogsDiv.textContent = debugLogs.join('\n');
                    debugLogsDiv.scrollTop = debugLogsDiv.scrollHeight;
                    showLogsBtn.textContent = 'üîç Masquer les logs';
                } else {
                    debugPanel.style.display = 'none';
                    showLogsBtn.textContent = 'üîç Afficher les logs de debug';
                }
            });
            
            // Bouton pour vider les logs
            clearLogsBtn.addEventListener('click', () => {
                debugLogs = [];
                debugLogsDiv.textContent = '';
                debugLog('Logs vid√©s');
            });
            
            // Bouton pour copier les logs
            copyLogsBtn.addEventListener('click', () => {
                const logsText = debugLogs.join('\n');
                navigator.clipboard.writeText(logsText).then(() => {
                    alert('Logs copi√©s dans le presse-papiers !');
                }).catch(() => {
                    // Fallback pour les navigateurs plus anciens
                    const textarea = document.createElement('textarea');
                    textarea.value = logsText;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    alert('Logs copi√©s dans le presse-papiers !');
                });
            });
            
            // Cr√©er la couche
            createLayerBtn.addEventListener('click', async () => {
                const selectedType = commerceTypeSelect.value;
                if (!selectedType) {
                    alert('Veuillez s√©lectionner un type de commerce');
                    return;
                }
                
                // Obtenir les limites de la carte visible
                const bounds = map.getBounds();
                const bbox = [
                    bounds.getSouth(),
                    bounds.getWest(),
                    bounds.getNorth(),
                    bounds.getEast()
                ];
                
                layerType = selectedType;
                loadingDiv.style.display = 'block';
                createLayerBtn.disabled = true;
                
                try {
                    // Construire et ex√©cuter la requ√™te Overpass
                    const query = buildOverpassQuery(selectedType, bbox);
                    const data = await fetchOverpassData(query);
                    
                    // Convertir en GeoJSON
                    const geojson = overpassToGeoJSON(data);
                    currentData = geojson.features;
                    
                    // Supprimer la couche pr√©c√©dente
                    if (currentLayer) {
                        map.removeLayer(currentLayer);
                    }
                    
                    // Cr√©er la nouvelle couche
                    currentLayer = L.geoJSON(geojson, {
                        pointToLayer: function(feature, latlng) {
                            return L.circleMarker(latlng, {
                                radius: 8,
                                fillColor: '#e74c3c',
                                color: '#c0392b',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.8
                            });
                        },
                        onEachFeature: function(feature, layer) {
                            layer.bindPopup(createPopup(feature));
                        }
                    }).addTo(map);
                    
                    // Mettre √† jour l'interface
                    exportBtn.disabled = false;
                    layerInfo.style.display = 'block';
                    layerDetails.textContent = `${currentData.length} points trouv√©s (${selectedType})`;
                    
                    // Sugg√©rer un nom de couche
                    const typeLabel = commerceTypeSelect.selectedOptions[0].textContent.replace(/[ü•ñüõíüè™ü•©üëïüíäüå∏üíáüìöüíéüçΩÔ∏è‚òïüç∫üè¶‚õΩüè•üéìüìÆ]/g, '').trim();
                    layerNameInput.placeholder = `${typeLabel}_${new Date().toISOString().split('T')[0]}`;
                    
                } catch (error) {
                    alert('Erreur lors de la r√©cup√©ration des donn√©es: ' + error.message);
                } finally {
                    loadingDiv.style.display = 'none';
                    createLayerBtn.disabled = false;
                }
            });
            
            // Export
            exportBtn.addEventListener('click', () => {
                if (currentData.length === 0) {
                    alert('Aucune donn√©e √† exporter');
                    return;
                }
                
                const layerName = layerNameInput.value || layerNameInput.placeholder;
                
                // Cr√©er le GeoJSON complet
                const exportData = {
                    type: 'FeatureCollection',
                    name: layerName,
                    crs: {
                        type: 'name',
                        properties: {
                            name: 'urn:ogc:def:crs:EPSG::4326'
                        }
                    },
                    features: currentData
                };
                
                // Export en JSON (compatible QGIS)
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `${layerName}.geojson`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                alert(`Couche export√©e: ${layerName}.geojson\nVous pouvez l'importer dans QGIS via "Couche > Ajouter une couche > Ajouter une couche vecteur"`);
            });
        }
        
        // Fonctions utilitaires
        function buildOverpassQuery(type, bbox) {
            const [south, west, north, east] = bbox;
            return `
                [out:json][timeout:25];
                (
                    node[${type}](${south},${west},${north},${east});
                    way[${type}](${south},${west},${north},${east});
                    relation[${type}](${south},${west},${north},${east});
                );
                out geom;
            `;
        }
        
        function createPopup(feature) {
            const props = feature.properties;
            let content = `<div class="popup-content">`;
            
            if (props.name) {
                content += `<h4>${props.name}</h4>`;
            } else {
                content += `<h4>${layerType.split('=')[1].replace('_', ' ')}</h4>`;
            }
            
            // Adresse
            const addressParts = [];
            if (props['addr:housenumber']) addressParts.push(props['addr:housenumber']);
            if (props['addr:street']) addressParts.push(props['addr:street']);
            if (props['addr:city']) addressParts.push(props['addr:city']);
            
            if (addressParts.length > 0) {
                content += `<p class="address">üìç ${addressParts.join(', ')}</p>`;
            }
            
            // Informations suppl√©mentaires
            if (props.phone) content += `<p>üìû ${props.phone}</p>`;
            if (props.website) content += `<p>üåê <a href="${props.website}" target="_blank">Site web</a></p>`;
            if (props['opening_hours']) content += `<p>üïí ${props['opening_hours']}</p>`;
            
            // Tags OSM (s√©lection des plus pertinents)
            const relevantTags = {};
            Object.keys(props).forEach(key => {
                if (key.includes('shop') || key.includes('amenity') || key.includes('cuisine') || 
                    key.includes('brand') || key.includes('operator')) {
                    relevantTags[key] = props[key];
                }
            });
            
            if (Object.keys(relevantTags).length > 0) {
                content += `<div class="tags">`;
                content += `<strong>Tags OSM:</strong><br>`;
                Object.entries(relevantTags).forEach(([key, value]) => {
                    content += `<span class="tag">${key}: ${value}</span>`;
                });
                content += `</div>`;
            }
            
            content += `</div>`;
            return content;
        }
        
        async function fetchOverpassData(query) {
            // Essayer plusieurs proxies CORS
            const proxies = [
                'https://cors-anywhere.herokuapp.com/',
                'https://api.codetabs.com/v1/proxy?quest=',
                'https://thingproxy.freeboard.io/fetch/'
            ];
            
            const apiUrl = 'https://overpass-api.de/api/interpreter';
            
            for (let i = 0; i < proxies.length; i++) {
                const proxyUrl = proxies[i];
                const fullUrl = proxyUrl + encodeURIComponent(apiUrl);
                
                debugLog('Tentative proxy ' + (i + 1) + ': ' + proxyUrl);
                
                try {
                    const response = await fetch(fullUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'text/plain',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: query
                    });
                    
                    debugLog('Proxy ' + (i + 1) + ' - Status: ' + response.status);
                    
                    if (response.ok) {
                        const data = await response.json();
                        debugLog('Donn√©es OSM r√©elles r√©cup√©r√©es ! ' + data.elements?.length + ' √©l√©ments');
                        return data;
                    } else {
                        const errorText = await response.text();
                        debugLog('Proxy ' + (i + 1) + ' erreur HTTP: ' + response.status + ' - ' + errorText.substring(0, 200), 'error');
                    }
                    
                } catch (error) {
                    debugLog('Proxy ' + (i + 1) + ' √©chou√©: ' + error.message, 'error');
                }
            }
            
            // Si tous les proxies √©chouent, essayer directement (peut marcher en local)
            debugLog('Tentative directe vers Overpass API...');
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain'
                    },
                    body: query
                });
                
                debugLog('Requ√™te directe - Status: ' + response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    debugLog('SUCC√àS! Donn√©es OSM directes r√©cup√©r√©es ! ' + data.elements?.length + ' √©l√©ments');
                    return data;
                } else {
                    const errorText = await response.text();
                    debugLog('Requ√™te directe √©chou√©e: ' + response.status + ' - ' + errorText.substring(0, 200), 'error');
                }
            } catch (error) {
                debugLog('Requ√™te directe √©chou√©e: ' + error.message, 'error');
            }
            
            // Si tout √©choue, utiliser les donn√©es de d√©monstration
            debugLog('Toutes les m√©thodes ont √©chou√©, utilisation des donn√©es de d√©monstration', 'warn');
            return await fetchOverpassDataAlternative(query);
        }
        
        async function fetchOverpassDataAlternative(query) {
            console.log('Tentative m√©thode alternative...');
            console.log('Requ√™te re√ßue:', query);
            
            // Extraire correctement le type de commerce de la requ√™te Overpass
            const lines = query.split('\n');
            let commerceType = 'shop=bakery'; // d√©faut
            
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed.includes('node[') && trimmed.includes('=')) {
                    const match = trimmed.match(/node\[([^=]+=[^\]]+)\]/);
                    if (match) {
                        commerceType = match[1];
                        break;
                    }
                }
            }
            
            console.log('Type de commerce extrait:', commerceType);
            
            // G√©n√©rer des donn√©es de d√©monstration bas√©es sur le type s√©lectionn√©
            const mockData = generateMockData(commerceType);
            
            console.log(`Utilisation des donn√©es de d√©monstration pour: ${commerceType}`);
            return mockData;
        }
        
        function generateMockData(commerceType) {
            const [key, value] = commerceType.split('=');
            
            // Donn√©es d√©taill√©es par type de commerce
            const commerceData = {
                'shop=bakery': {
                    names: ['Boulangerie Paul', 'Au Pain Dor√©', 'La Mie de Pain', 'Boulangerie Artisanale', 'Le P√©trin d\'Or', 'Boulangerie Saint-Germain'],
                    hours: 'Mo-Sa 06:30-19:30; Su 07:00-13:00',
                    brands: ['Paul', 'Banette', 'Boulangerie Moderne'],
                    specialties: ['croissant', 'pain_de_campagne', 'baguette_tradition']
                },
                'shop=pharmacy': {
                    names: ['Pharmacie Centrale', 'Pharmacie du March√©', 'Grande Pharmacie', 'Pharmacie de la Paix', 'Pharmacie Moderne', 'Pharmacie Saint-Michel'],
                    hours: 'Mo-Sa 09:00-19:30',
                    brands: ['Pharmacie Lafayette', 'Citypharma', 'Pharmacie Monge'],
                    specialties: ['conseil', 'hom√©opathie', 'orthop√©die']
                },
                'amenity=restaurant': {
                    names: ['Le Bistrot Parisien', 'Chez Marcel', 'La Table du Chef', 'Le Petit Fran√ßais', 'Restaurant du March√©', 'La Bonne Fourchette'],
                    hours: 'Mo-Su 12:00-14:30,19:00-23:00',
                    cuisines: ['french', 'italian', 'mediterranean', 'traditional'],
                    specialties: ['menu_du_jour', 'carte_des_vins', 'terrasse']
                },
                'amenity=cafe': {
                    names: ['Caf√© de Flore', 'Le Procope', 'Caf√© Central', 'Le Caf√© Noir', 'Caf√© des Arts', 'Le Petit Caf√©'],
                    hours: 'Mo-Su 07:00-01:00',
                    services: ['wifi', 'terrasse', 'breakfast'],
                    specialties: ['espresso', 'croissant', 'plat_du_jour']
                },
                'shop=supermarket': {
                    names: ['Monoprix', 'Franprix', 'Carrefour City', 'Casino', 'G20', 'Naturalia'],
                    hours: 'Mo-Sa 08:30-21:00; Su 09:00-13:00',
                    brands: ['Monoprix', 'Carrefour', 'Casino'],
                    services: ['parking', 'livraison', 'bio']
                },
                'shop=clothes': {
                    names: ['Mode & Style', 'Fashion Store', 'Boutique √âl√©gance', 'Trends', 'Style Parisien', 'La Mode'],
                    hours: 'Mo-Sa 10:00-19:00',
                    specialties: ['femme', 'homme', 'accessoires'],
                    brands: ['Zara', 'H&M', 'Boutique locale']
                },
                'shop=butcher': {
                    names: ['Boucherie Moderne', 'Chez le Boucher', 'Boucherie Artisanale', 'La Bonne Viande', 'Boucherie Traditionnelle', 'Le Carnivore'],
                    hours: 'Tu-Sa 08:00-19:00; Su 08:00-13:00',
                    specialties: ['viande_fraiche', 'charcuterie', 'volaille'],
                    services: ['d√©coupe', 'conseil', 'commande']
                }
            };
            
            const data = commerceData[commerceType] || commerceData['shop=bakery'];
            
            // Obtenir les limites de la carte actuelle
            const bounds = map.getBounds();
            const centerLat = bounds.getCenter().lat;
            const centerLng = bounds.getCenter().lng;
            
            // G√©n√©rer 6-10 points r√©partis de mani√®re r√©aliste
            const numPoints = Math.floor(Math.random() * 5) + 6;
            const elements = [];
            
            // G√©n√©rer des rues typiques selon la zone g√©ographique
            const isInFrance = centerLat > 41 && centerLat < 51 && centerLng > -5 && centerLng < 10;
            const isInUK = centerLat > 49 && centerLat < 61 && centerLng > -11 && centerLng < 2;
            
            let streets, cityName;
            if (isInFrance) {
                streets = ['Rue de Rivoli', 'Boulevard Saint-Germain', 'Avenue des Champs-√âlys√©es', 'Rue Montmartre', 'Boulevard Voltaire', 'Rue de la Paix'];
                cityName = centerLat > 48.7 && centerLat < 48.9 ? 'Paris' : 'Lyon';
            } else if (isInUK) {
                streets = ['High Street', 'King\'s Road', 'Oxford Street', 'Baker Street', 'Regent Street', 'Bond Street'];
                cityName = centerLat > 51.3 && centerLat < 51.7 ? 'London' : 'Manchester';
            } else {
                streets = ['Main Street', 'Broadway', 'First Avenue', 'Oak Street', 'Park Avenue', 'Elm Street'];
                cityName = 'Downtown';
            }
            
            for (let i = 0; i < numPoints; i++) {
                // Distribution plus r√©aliste des points
                const angle = (i / numPoints) * 2 * Math.PI + Math.random() * 0.5;
                const distance = Math.random() * 0.008 + 0.002; // 200m √† 1km du centre
                
                const lat = centerLat + Math.cos(angle) * distance;
                const lng = centerLng + Math.sin(angle) * distance;
                
                const element = {
                    type: 'node',
                    id: 2000 + i,
                    lat: lat,
                    lon: lng,
                    tags: {
                        name: data.names[i % data.names.length],
                        [key]: value,
                        'addr:housenumber': String(Math.floor(Math.random() * 200) + 1),
                        'addr:street': streets[i % streets.length],
                        'addr:city': cityName,
                        'addr:postcode': String(Math.floor(Math.random() * 90000) + 10000),
                        'opening_hours': data.hours
                    }
                };
                
                // Ajouter des d√©tails sp√©cifiques selon le type
                if (data.brands && Math.random() > 0.6) {
                    element.tags.brand = data.brands[Math.floor(Math.random() * data.brands.length)];
                }
                
                if (data.cuisines && Math.random() > 0.5) {
                    element.tags.cuisine = data.cuisines[Math.floor(Math.random() * data.cuisines.length)];
                }
                
                if (data.specialties && Math.random() > 0.4) {
                    element.tags.specialty = data.specialties[Math.floor(Math.random() * data.specialties.length)];
                }
                
                // T√©l√©phone pour 70% des commerces
                if (Math.random() > 0.3) {
                    if (isInFrance) {
                        element.tags.phone = `+33 1 ${Math.floor(Math.random() * 90 + 10)} ${Math.floor(Math.random() * 90 + 10)} ${Math.floor(Math.random() * 90 + 10)} ${Math.floor(Math.random() * 90 + 10)}`;
                    } else if (isInUK) {
                        element.tags.phone = `+44 20 ${Math.floor(Math.random() * 9000 + 1000)} ${Math.floor(Math.random() * 9000 + 1000)}`;
                    } else {
                        element.tags.phone = `+1 ${Math.floor(Math.random() * 900 + 100)} ${Math.floor(Math.random() * 900 + 100)} ${Math.floor(Math.random() * 9000 + 1000)}`;
                    }
                }
                
                // Site web pour 40% des commerces
                if (Math.random() > 0.6) {
                    const cleanName = element.tags.name.toLowerCase().replace(/[^a-z0-9]/g, '-');
                    element.tags.website = `https://www.${cleanName}.com`;
                }
                
                // Email pour 30% des commerces
                if (Math.random() > 0.7) {
                    const cleanName = element.tags.name.toLowerCase().replace(/[^a-z0-9]/g, '');
                    element.tags.email = `contact@${cleanName}.com`;
                }
                
                elements.push(element);
            }
            
            return { elements };
        }
        
        function overpassToGeoJSON(data) {
            const features = [];
            
            data.elements.forEach(element => {
                let geometry = null;
                let coordinates = null;
                
                if (element.type === 'node') {
                    geometry = {
                        type: 'Point',
                        coordinates: [element.lon, element.lat]
                    };
                } else if (element.type === 'way' && element.geometry) {
                    if (element.geometry.length > 1) {
                        coordinates = element.geometry.map(point => [point.lon, point.lat]);
                        // Si c'est un polygone ferm√©
                        if (coordinates[0][0] === coordinates[coordinates.length-1][0] && 
                            coordinates[0][1] === coordinates[coordinates.length-1][1]) {
                            geometry = {
                                type: 'Polygon',
                                coordinates: [coordinates]
                            };
                        } else {
                            geometry = {
                                type: 'LineString',
                                coordinates: coordinates
                            };
                        }
                    }
                }
                
                if (geometry) {
                    features.push({
                        type: 'Feature',
                        properties: {
                            osm_id: element.id,
                            osm_type: element.type,
                            ...element.tags
                        },
                        geometry: geometry
                    });
                }
            });
            
            return {
                type: 'FeatureCollection',
                features: features
            };
        }
        
        // Fonction pour attendre que Leaflet soit charg√© avec timeout
        function waitForLeaflet(attempts = 0) {
            console.log(`Tentative ${attempts + 1}: L = `, typeof L);
            
            if (typeof L !== 'undefined') {
                console.log('Leaflet d√©tect√© apr√®s', attempts + 1, 'tentatives');
                initializeApp();
            } else if (attempts < 50) { // Maximum 5 secondes
                setTimeout(() => waitForLeaflet(attempts + 1), 100);
            } else {
                console.error('Timeout: Leaflet non charg√© apr√®s 5 secondes');
                document.getElementById('map').innerHTML = 
                    '<div style="padding: 20px; text-align: center; color: red; background: white;">' +
                    'Erreur: Impossible de charger Leaflet<br>' +
                    'Veuillez rafra√Æchir la page ou v√©rifier votre connexion internet.' +
                    '</div>';
            }
        }
        
        // D√©marrer l'application
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', waitForLeaflet);
        } else {
            waitForLeaflet();
        }
    </script>
</body>
</html>